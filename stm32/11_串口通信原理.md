# 串口通信原理

## 通信接口背景知识

### 并行通信

传输原理：数据各个位同时传输。

优点：速度快。

缺点：占用引脚资源多。

### 串行通信

传输原理：数据按位顺序传输。

优点：占用引脚资源少。

缺点：速度相对较慢。

## 串行通信分类

按照数据传送方向，分为：

* 单工： 数据传输只支持数据在一个方向上传输。
* 半双工： 允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信。
* 全双工： 允许数据同时在两个方向上传输，因此，全双工短信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。

# 通信接口背景知识

## 同步通信

带时钟同步信号传输。

-SPI, IIC通信接口

## 异步通信

不带时钟同步信号。

-UART(通用异步收发器)，单总线。

约定波特率，起始为，结束位等。

### 常见的串行通信接口：

通信标准 | 引脚说明 | 通信方式 | 通信方向
---|---|---|---
UART(通用异步收发器)| TXD:发送端,RXD:接收端，GND| 异步通信|全双工
单总线(1-write)|DQ:发送/接收端|异步通信|半双工
SPI|SCK:同步时钟, MISO:主机输入，从机输出，MOSI：主机输出，从机输入|同步通信|全双工
I2C|SCL:同步时钟，SDA：数据输入/输出端|同步通信|半双工

### 异步通信UART包含三点知识：

1. 物理层（电气层：接口决定）：通信接口(RS232,485,422,TTL)
2. 数据格式(数据层：芯片决定)
3. 通信协议（协议层：程序决定）

### TTL串口， RS232, RS485, RS422

接口类型 | 逻辑1典型值| 逻辑0典型值 | 说明 | 优缺点
---|---|---|---|---
TTL|5/3.3V|0|一般MCU串口引脚都支持TTL|
RS232|+15v|-15v|3线全双工，点对点|接口电平高，传输速度相对较低，传输距离近
RS485|压差+(2~6)V|压差-(2~6v)|2线半双工，点对多，主从通信。使用压差传递信号|传输速度高可达10M，抗干扰能力强，距离远。
RS422|使用较少

## STM32串口通信基础

### 数据接收过程

MCU内核<-输入数据缓冲器<-串行输入移位寄存器<-串行数据输入(RXD)<-外部设备

### 数据发送过程

MCU内核->输出数据缓冲器->串行输出移位寄存器->串行数据输出(TXD)->外部设备

## STM32串口异步通信需要定义的参数

1. 起始位
2. 数据位(8位或者9位)
3. 奇偶校验位(第9位)
4. 停止位(1,15,2位)
5. 波特率设置

# 串口框图

中文参考手册

过采样设置OVER8， 16倍过采样容错性好，8倍过采样容错率差速度快。

## 波特率生成

接收器和发送器(Rx和Tx)的波特率设置为USARTx_BRR寄存器中编程的相同值。

公式1：适用于标准USART(包括SPI模式)的波特率(OVER8=0 或1)

16倍过采样时的公式：

Tx/Rx baud = fck / USARTDIV

8倍过采样时的公式：

Tx/Rx baud = 2 * fck / USARTDIV

如果FCK=216MHz,波特率为115200,那么USARTDIV=1875d=753H

# 串口发送过程与配置

## 参考资料

STM32中文参考手册 通用同步异步收发器章节

配套教程 STM32开发指南 串口实验章节

## HAL库中串口寄存器定义文件：

`STM32f767xx.h`

## 串口字节发送流程

1. 编程USARTx_CR1的M位来定义字长。
2. 编程USARTx_CR2的STOP位来定义停止位位数。
3. 编程USARTx_BRR寄存器确定波特率。
4. 使能USARTx_CR1的UE位使能USARTx。
5. 如果进行多缓冲通信，配置USARTx_CR3的DMA使能(DMAT)。具体请参考后面的DMA实验。
6. 使能USARTx_CR1的TE位使能发送器。
7. 向发送数据寄存器TDR写入要发送的数据（对于M3，发送和接收共用DR寄存器）。
8. 向TRD寄存器写入最后一个数据后，等待状态寄存器USARTx_SR(ISR)的TC位置1，传输完成。

1~6是配置步骤，7~8是发送数据。

## 串口字节发送流程（HAL库函数）

配置步骤1~6：

配置字长，停止位，奇偶校验位， 波特率等

HAL_SatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart);

该函数内部会引用标识符__HAL_USART_ENABLE使能相应串口。

步骤7~8发送数据和等待发送完成：

HAL_StatusTypeDef HAL_USART_Transmit(USART_HangleTypeDef* husart, uint8_t *pTxData, uint16_t Size, uint32_t Timeout);

\_\_Weak关键字的好处

1. 对于事先已经定义好的一个流程，我们只希望修改流程中的某部分与用户相关的代码，这个时候我们可以采用弱函数定义一个空函数，然后让用户自行定义该函数。这样做的好处是我们不会对既有程序流程做任何更改
2. HAL库中大量使用__weak关键字修饰外设回调函数。HAL库中大量使用外设回调函数，该函数在外设初始化函数中被调用。
3. 外设回调函数供用户编写MCU相关程序，大大提高程序的通用移植性。

## 串口发送程序配置过程(HAL库)：

1. 初始化串口相关参数，使能串口:HAL_UART_Init();
2. 串口相关IO口配置，复用配置：
		
		在`HAL_UART_MspInit`中调用`HAL_GPIO_Init`函数。
3. 发送数据，并等待数据发送完成：

		`HAL_UART_Transmit()`函数

# 串口接收流程

## 配置流程

1. 编程`USARTx_CR1`的`M`位来定义字长。
2. 编程`USARTx_CR2`的`STOP`位来定义停止位位数。
3. 编程`USARTx_BRR`寄存器确定波特率。
4. 使能`USARTx_CR1`的`UE`位使能`USARTx`。
5. 如果进行多缓冲通信，配置`USARTx_CR3`的`DMA`使能(DMAT)。具体请参考后面的DMA实验。
6. 使能	`USARTx_CR1`的`RE`位为1使能接收器。
7. 如果要使能接收中断（接收到数据后产生中断），使能`USARTx_CR1`的`RXNEIE`位为1。

## 当串口接收到数据时

1. `USARTx_SR`(ISR)的RXNE位置1。表明位移寄存器内容已经传输到RDR(DR)寄存器。已经接收到数据并且等待读取。
2. 如果开启了接收数据中断(`USARTx_CR1`寄存器的`RxNEIE`位为1)，则会产生中断。（程序上会执行中断服务函数）
3. 如果开启了其他中断（帧错误等），相应标志位会置1。
4. 读取`USARTx_TDR(DR)`寄存器的值，该操作将会自动将RXNE位清零，等待下次接收后置位。

## 串口接收流程（HAL库）

### 配置过程

接收配置步骤1~6和发送流程一样，调用`HAL_UART_Init`函数

`HAL_StatusTypeDefHAL_UART_Init(UART_HandleTypeDef *huart);`

步骤7开启接收中断：

`HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, unit16_t Size);`

### 接收数据过程

* 步骤1获取状态标志位通过标识符实现：

`__HAL_UART_GET_FLAH //判断状态标志位`
`__HAL_UART_GET_IT_SOURCE //判断中断标志位`

* 步骤2~3中断服务函数：

```
void USARTx_IRQHandler(void);//(x=1~3,6)
void USARTx_IRQHandler(void);//(x=4,5,7,8)
```
在启动文件`startup_stm32fxxx.s`中查找。

* 步骤4接收读取数据：

```
HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout);
```

## 串口接收中断程序配置过程（HAL库）：

1. 初始化串口相关参数，使能串口：`HAL_UART_Init();`
2. 串口相关IO口配置，复用配置：在`HAL_UART_MspInit`中调用`HAL_GPIO_Init`函数。
3. 串口接收中断优先级配置和使能: 
	
	```
	HAL_NVIC_EnableIRQ();
	HAL_NVIC_SetPriority();
	```
4. 使能串口接收中断：`HAL_UART_Receive_IT();`
5. 编写中断服务函数:`USARTx_IRQHandler`

# 串口通信实验

## 实现功能

从电脑串口助手发送长度200以内的任意长度的字符串给STM32串口1（字符串以回车换行标识结束），STM32接收到字符串之后，一次性通过串口1把所有数据返回给电脑。

```
#define USART_REC_LEN 200 //定义最大接受字节数200
u8 USART_RX_BUF[USART_REC_LEN];//接收缓冲，最大USART_REC_LEN个字节，末字节为换行符
u16 USART_RX_STA; //接收状态标记
```

`USART_RX_STA`的15位是接收完成标志，14位是接收到0x0D标志，13~0位是接收到的有效数据个数。

接收到`0x0D`时14位置为1，否则置位为0.收到`0x0A`时判断14位是否为1，若为1则置15位为1。

当接收到字符串时，

1. 判断最高位是不是1，也就是上次的数据有没有被读取。
	如果最高位是0，继续进行第二步，否则结束。
2. 判断次高位是不是1。如果是1，则判断该数据是不是0x0a。如果是，置最高位为1；否则继续。
3. 13~0位加一。


