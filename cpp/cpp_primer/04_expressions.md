[TOC]

# 4. Expressions

## 4.1 Fundamentals

## 4.1.1 Basic Concepts

UnaryÔºà‰∏ÄÂÖÉÔºâÊìç‰ΩúÁ¨¶ÂíåbinaryÔºà‰∫åÂÖÉÔºâ Êìç‰ΩúÁ¨¶„ÄÇ

Unary Operators: `&`,` *` ÂèñÂú∞ÂùÄÂíåÂéªÂºïÁî®„ÄÇ

‰∫åÂÖÉÊìç‰ΩúÁ¨¶Ôºö`==`Âíå`*`Áõ∏Á≠âÂíå‰πòÊ≥ï„ÄÇ

ËøòÊúâ‰∏Ä‰∏™‰∏âÂÖÉÁöÑÊìç‰ΩúÁ¨¶Ôºå‰∏Ä‰∏™Êó†ÈôêÂÖÉÁöÑÊìç‰ΩúÁ¨¶„ÄÇ

‰ºòÂÖàÁ∫ßÂíåÁõ∏Âêå‰ºòÂÖàÁ∫ßÁöÑ‰ºòÂÖàÁ®ãÂ∫¶„ÄÇ

#### Âè≥ÂÄºÂíåÂ∑¶ÂÄº

Âè≥ÂÄºÔºö Expression that yields a value but not the associated location, if any, of that value.

Â∑¶ÂÄºÔºöAn expression that yields an object or function. A nonconst lvalue that denotes an object may be the left-hand operand of assignment.

Â∑¶ÂÄºÂèØ‰ª•Âú®‰∏Ä‰∏™assignmentÁöÑÂ∑¶ÊâãËæπÔºåËÄåÂè≥ÂÄºÂ∞±‰∏çË°å„ÄÇ

ÊØè‰∏Ä‰∏™c++ÈáåÁöÑË°®ËææÂºè‰∏çÊòØÂè≥ÂÄºÂ∞±ÊòØÂ∑¶ÂÄº„ÄÇÂú®C++ÈáåÔºåÂ∑¶ÂÄºË°®ËææÂºèË°®Á§∫‰∏Ä‰∏™ÂØπË±°ÊàñËÄÖ‰∏Ä‰∏™ÂáΩÊï∞„ÄÇÁÑ∂ËÄåÔºå‰∏Ä‰∫õÂ∑¶ÂÄºÔºå‰æãÂ¶Ç`const`ÔºåÂπ∂‰∏çÊòØ‰ª£Ë°®ËµãÂÄºÁöÑ„ÄÇÊ≠§Â§ñÔºå‰∏Ä‰∫õËÉΩÂ§üËøîÂõûÂØπË±°ÁöÑÊòØÂè≥ÂÄºË°®ËææÂºèÔºå‰∏çÊòØÂ∑¶ÂÄº„ÄÇÁ≤óÁï•Êª¥ËØ¥ÔºåÂΩìÊàë‰ª¨Áî®‰∏Ä‰∏™ÂØπË±°ÁöÑÂè≥ÂÄºÊó∂Êàë‰ª¨Áî®Ëøô‰∏™ÂØπË±°ÁöÑÊï∞ÂÄºÔºåÁî®Â∑¶ÂÄºÊó∂Áî®Ëøô‰∏™ÂØπË±°ÁöÑÊ†áÂøóÁ¨¶ÔºàÂú®ÂÜÖÂ≠ò‰∏≠ÁöÑ‰ΩçÁΩÆÔºâ„ÄÇÂΩìÊàë‰ª¨ÈúÄË¶ÅÂ∑¶ÂÄºÊó∂Êàë‰ª¨ÂèØ‰ª•Áî®‰∏™Âè≥ÂÄºÔºåÂèçËøáÊù•‰∏çË°åüôÖ‚Äç‚ôÇÔ∏è„ÄÇ

* ËµãÂÄºÊìç‰ΩúÈúÄË¶Å‰∏Ä‰∏™ÔºàÈùûconstÔºâÁöÑÂ∑¶ÂÄº‰Ωú‰∏∫ÂÆÉÂ∑¶ÊâãÊìç‰ΩúÁ¨¶ÔºåÂπ∂‰∏îÊääÂÆÉÂèòÊàê‰∏Ä‰∏™Â∑¶ÂÄº„ÄÇ
* ÂèñÂùÄÈúÄË¶Å‰∏Ä‰∏™Â∑¶ÊâãÊìç‰ΩúÁ¨¶ÔºåÂπ∂‰∏îÊääÂÆÉÂèòÊàê‰∏Ä‰∏™Âè≥ÂÄºÔºåËøîÂõû‰∏Ä‰∏™ÊåáÈíà„ÄÇ
* dereferenceÂíå‰∏ãÊ†áÂíåËø≠‰ª£Âô®ÁöÑdereferenceËøòÊúâstringÂíåvectorÁöÑ‰∏ãÊ†áÈÉΩÊòØËøîÂõûÂ∑¶ÂÄºÁöÑ„ÄÇ
* ÈÄíÂ¢ûÂíåÈÄíÂáè‰πüÈÉΩËøîÂõûÂ∑¶ÂÄº„ÄÇ

### 4.1.2 ‰ºòÂÖàÁ∫ß 

Êúâ‰∏§‰∏™ÊàñÂ§ö‰∏™Êìç‰ΩúÁ¨¶ÁöÑË°®ËææÂºèÊòØÂ§çÂêàË°®ËææÂºè„ÄÇ‰ºòÂÖàÁ∫ßÂÜ≥ÂÆö‰∫ÜË∞ÅÂíåË∞Å‰∏ÄÁªÑ„ÄÇÁºñÁ®ãÁöÑ‰∫∫ÂèØ‰ª•ÈáçÂÜôËøô‰∫õËßÑÂàôÔºöÈÄöËøá‰ΩøÁî®Êã¨Âè∑„ÄÇ

* Precedence: 3 + 4 * 5 = 23,‰∏çÊòØ35.
* associativity: 20-15-3 = 2 ‰∏çÊòØ8.

Â¶Ç‰∏ãË°®ÊâÄÁ§∫ÔºåÊØè‰∏Ä‰∏™Áõ∏ÂêåÁöÑÊ†èÊúâÁõ∏ÂêåÁöÑ‰ºòÂÖàÁ∫ßÔºåÊØî‰∏ã‰∏Ä‰∏™Ê†èÁöÑ‰ºòÂÖàÁ∫ßÈ´ò„ÄÇ

| Associativity     | Operator      | function               | use                   |
| ----------------- | ------------- | ---------------------- | --------------------- |
| L                 | ::            | Global scope           | ::name                |
| L                 | ::            | Class scope            | Class::name           |
| L                 | ::            | Namespace scope        | Namespace::name       |
| ---------------   | ------------  | ------------------     | -----------------     |
| L                 | .             | Member selectors       | Object.member         |
| L                 | ->            | Member selectors       | Pointer->member       |
| L                 | []            | Subscript              | expr[expr]            |
| L                 | ()            | function call          | name(expr_list)       |
| L                 | ()            | Type construction      | type(expr_list)       |
| ----------------  | ------------  | ----------------       | -----------------     |
| R                 | ++            | postfix increment      | lvalue++              |
| R                 | --            | postfix decrement      | lvalue--              |
| R                 | typeid        | type ID                | typeid(type)          |
| R                 | typeid        | Run-time type ID       | typeid(expr)          |
| R                 | explicit cast | type conversion        | cast_name<type>(expr) |
| ----------------- | ---------     | ------------------     | ------------------    |
| R                 | ++            | prefix increment       | ++lvalue              |
| R                 | --            | prefix decrement       | ‚Äîlvalue               |
| R                 | ~             | bitwise NOT            | ~expr                 |
| R                 | !             | logical NOT            | !expr                 |
| R                 | -             | unary minus            | -expr                 |
| R                 | +             | Unary plus             | +expr                 |
| R                 | *             | dereference            | *expr                 |
| R                 | &             | Address-of             | &lvalue               |
| R                 | ()            | Type conversion        | (type)expr            |
| R                 | sizeof        | size of object         | sizeof expr           |
| R                 | sizeof        | size of type           | sizeof(type)          |
| R                 | sizeof..      | size of parameter pack | sizeof‚Ä¶(name)         |
| R                 | new           | allocate object        | new type              |
| R                 | new[]         | allocate array         | new type[size]        |
| R                 | delete        | deallocate object      | delete expr           |
| R                 | delete[]      | deallocate array       | delete[] expr         |
| R                 | noexcept      | can expr throw         | noexcept(expr)        |
| -------------     | ---------     | ----------------       | ----------------      |
| L                 | ->*           | ptr to member select   | ptr->*ptr_to_member   |
| L                 | .*            | ptr to member select   | obj.*ptr_to_member    |
| -------------     | --------      | -----------------      | -----------------     |
| L                 | *             | multiply               | expr * expr           |
| L                 | /             | divide                 | expr / expr           |
| L                 | %             | modulo(remainder)      | expr % expr           |
| --------------    | --------      | ------------------     | -----------------     |
| L                 | +             | add                    | expr + expr           |
| L                 | -             | subtract               | expr - expr           |
| --------------    | -------       | -----------------      | -----------------     |
| L                 | <<            | bitwise shift left     | expr << expr          |
| L                 | `>>`          | bitwise shift right    | expr >> expr          |
| -------------     | ---------     | ----------------       | -----------------     |
| L                 | <             | less than              | expr < expr           |
| L                 | <=            | less than or equal     | expr <= expr          |
| L                 | >             | greater than           | expr > expr           |
| L                 | `>=`          | greater than or equal  | expr >= expr          |
| ---------------   | ----------    | -----------------      | -------------------   |
| L                 | ==            | equality               | expr == expr          |
| L                 | !=            | inequality             | expr != expr          |
| ----------------  | ---------     | -----------------      | --------------------  |
| L                 | &             | bitwise AND            | expr & expr           |
| ----------------  | --------      | -----------------      | --------------------  |
| L                 | ^             | bitwise XOR            | expr ^ expr           |
| ---------------   | --------      | ----------------       | -----------------     |
| L                 | \|            | bitwise OR             | expr \| expr          |
| --------------    | ---------     | -----------------      | -----------------     |
| L                 | &&            | logical AND            | expr && expr          |
| -------------     | ---------     | ------------------     | -----------------     |
| L                 | \|\|          | logical OR             | expr \|\| expr        |
| -------------     | --------      | -----------------      | -----------------     |
| R                 | ?:            | conditional            | expr?expr:expr        |
| --------------    | -------       | ------------------     | -----------------     |
| R                 | =             | assignment             | lvalue = expr         |
| R                 | *=, /=, %=,   | compound assign        | lvalue += expr        |
| R                 | +=, -=,       |                        |                       |
| R                 | <<=, >>=,     |                        |                       |
| R                 | &=, \|=, ^=   |                        |                       |
| --------------    | ---------     | --------------------   | -----------------     |
| R                 | throw         | throw exception        | throw expr            |
| -----------       | -------       | ---------------        | ---------------       |
| L                 | ,             | comma                  | expr, expr            |
| ----------        | ---------     | ----------------       | --------------        |

### 4.1.3 Á≠âÂºèÁöÑÈ°∫Â∫è

Precedence ÊåáÂÆö‰∫ÜÊìç‰ΩúÁ¨¶ÊòØÂ¶Ç‰ΩïÂàÜÁªÑÁöÑ„ÄÇÂú®‰∏ãÈù¢ÁöÑË°®ËææÂºè‰∏≠Ôºö

```cpp
int i = f1() * f2();
```

Êàë‰ª¨Áü•ÈÅì‰∫Ü$f1$Âíå$f2$‰∏ÄÂÆöÊòØÂú®‰πòÊ≥ïÂÆåÊàê‰πãÂâçË¢´Ë∞ÉÁî®ÁöÑ„ÄÇ‰ΩÜÊòØÊàë‰ª¨‰∏çËÉΩÁü•ÈÅì$f1$ÊòØ‰∏çÊòØÂú®$f2$‰πãÂâçË¢´Ë∞ÉÁî®ÁöÑ„ÄÇ

Áî±‰∫éÊ≤°ÊúâÊåáÂÆöÊâßË°åÈ°∫Â∫èÔºå`<<`Á¨¶Âè∑Âπ∂‰∏ç‰øùËØÅ‰ªÄ‰πàÊó∂ÂÄôËøêË°åËØ•Á®ãÂ∫è„ÄÇ‰æãÂ¶ÇÔºå‰∏ãÈù¢ÁöÑË°®ËææÂºèÂ∞±ÊòØundefinedÔºö

```cpp
int i = 0;
cout << i << " " << ++i << endl; //undefined
```

Â¶ÇÊûúÂÖàËøêË°å‰∫Ü`++i`ÂàôÁªìÊûúÊòØ`1 1`ÔºåÂê¶ÂàôÂèØËÉΩÊòØ`0 1`„ÄÇËøô‰∏™ÁªìÊûúÊòØÊ≤°ÊúâÊòéÁ°ÆÂÆö‰πâÁöÑ„ÄÇ

ËøòÊúâ‰∏Ä‰∏™‰æãÂ≠êÔºö

```cpp
f() + g() * h() + j()
```

Âπ∂Ê≤°Êúâ‰øùËØÅÂõõ‰∏™ÂáΩÊï∞Ë∞ÅÂÖàËøêË°åË∞ÅÂêéËøêË°å„ÄÇ

#### Â∞èÂª∫ËÆÆÔºöÁÆ°ÁêÜÂ§çÂêàË°®ËææÂºè

1. ‰ΩøÁî®Êã¨Âè∑
2. ÂΩìËØ•‰∏Ä‰∏™Ë°®ËææÂºèÂÄºÊó∂ÂÄôÔºå‰∏çË¶ÅÂú®Âè¶‰∏Ä‰∏™Âú∞Êñπ‰πüÁî®Ëøô‰∏™Ë°®ËææÂºè„ÄÇ

## ÁÆóÊúØË°®ËææÂºè

precedenceÔºö

| Ë°®ËææÂºè         | ÂáΩÊï∞            | ‰ΩøÁî®           |
| ----------- | ------------- | ------------ |
| +           | ‰∏ÄÂÖÉÂä†           | + expr       |
| -           | ‰∏ÄÂÖÉÂáè           | - expr       |
| ----------- | ------------- | -----------  |
| *           | ‰πòÊ≥ï            | expr * expr  |
| /           | Èô§Ê≥ï            | expr / expr  |
| %           | Âèñ‰ΩôÊï∞           | expr % expr  |
| ----------  | -----------   | ------------ |
| +           | Âä†Ê≥ï            | expr + expr  |
| -           | ÂáèÊ≥ï            | expr - expr  |

#### Ê≥®ÊÑèÔºö Ê∫¢Âá∫ÂíåÂÖ∂ÂÆÉÁÆóÊúØÈîôËØØ

‰æãÂ¶Ç `short i = 32767;` 

`i++`Â∞ÜÂØºËá¥Ê∫¢Âá∫„ÄÇundefined value

ÂèñÊï¥Êñ∞Ê†áÂáÜÈÉΩÊòØÂ∞ÜÂ∞èÊï∞Ââ™ÊéâÔºàÂêë0ËßÑÁ∫¶Ôºâ„ÄÇ

`m % (-n)`Âíå`m % n`Á≠â‰ª∑

`(-m) % n`Âíå `- m % n`Á≠â‰ª∑

## 4.3 ÈÄªËæëÂíåÂÖ≥Á≥ªÊìç‰ΩúÁ¨¶

ÊâÄÊúâÁöÑÈÄªËæëÊìç‰ΩúÁ¨¶ÂíåÂÖ≥Á≥ªÊìç‰ΩúÁ¨¶ÈÉΩÊòØÂè≥ÂÄºÔºåËøîÂõûÂÄº‰πüÊòØÂè≥ÂÄº„ÄÇ

`&&`Âíå`||`ÈÉΩÊòØÂÖàËøêË°åÂ∑¶Èù¢ÂÜçËøêË°åÂêéÈù¢„ÄÇÈááÂèñshort-circuit evaluationÁ≠ñÁï•Ôºö

* ÂΩì‰∏î‰ªÖÂΩì`&&`ÁöÑÂ∑¶ËæπÊòØ`true`ÁöÑÊó∂ÂÄôÊâçÊé•ÁùÄÁÆó„ÄÇ
* ÂΩì‰∏î‰ªÖÂΩì`||`ÁöÑÂ∑¶ËæπÊòØ`false`ÁöÑÊó∂ÂÄôÊâçÊé•ÁùÄÁÆó„ÄÇ

‰∏Ä‰∫õÂà©Áî®Ëøô‰∫õÁâπË¥®ÁöÑÂÜôÊ≥ïÔºö

```
index != s.size() && !isspace(s[index])
```

È¶ñÂÖàÂÖàËøêË°åÂâçÈù¢ÁöÑÊ≤°ÊúâËææÂà∞Êú´Â∞æÔºåÂ¶ÇÊûúÁ¨¶ÂêàÂàôËøêË°åÂêéÈù¢„ÄÇ

```cpp
// s ÊòØÂ∏∏Êï∞ÁöÑÂºïÁî®Ôºå‰º†ÂùÄ‰ΩÜÊòØ‰∏çËÉΩÊõ¥Êîπ
for (const auto &s : text){ //for each element in text
  cout << s; //print the current element
  //blank lines and those that end with a period get a newline
  if (s.empty() || s[s.size() - 1] == '.')
  {
    cout << endl;
  } else
  {
    cout << " "; //otherwise just separate with a space
  }
}
```

ÂÄºÂæóÊ≥®ÊÑèÁöÑÊòØÔºåÊàë‰ª¨‰ΩøÁî®sÊòØreferenceÔºåÂõ†‰∏∫textÂíåstring‰ºöÂæàÂ§ßÔºåcopyËµ∑Êù•ÂæàÂç†ÂÜÖÂ≠òÔºåÂõ†‰∏∫‰∏çÊÉ≥ÊîπÊâÄ‰ª•ÂÜôÊàêconst„ÄÇ

### ÂÖ≥Á≥ªÊìç‰ΩúÁ¨¶

```cpp
//oops! this condition compares k to the bool result of i < j
if (i < j < k) //true if k is larger than 1!
```

`i<j`ËøîÂõûÁöÑÊòØ0ÊàñËÄÖ1

## 4.4 ËµãÂÄºÊìç‰ΩúÁ¨¶

ËµãÂÄºÁ¨¶Âè∑ÁöÑÂ∑¶ÊâãËæπÂøÖÈ°ªÊòØ‰∏Ä‰∏™ÂèØ‰ª•Êõ¥ÊîπÁöÑÂ∑¶ÂÄºÔºå

```cpp
int i = 0, j = 0, k = 0; //initializations, not assignment
const int ci = i; //initilization, not assignment
```

‰ª•‰∏ãÁöÑÂá†‰∏™ÈÉΩÊòØ‰∏çÂêàÊ≥ïÁöÑÔºö

```cpp
1024 = k; //Êï∞Â≠óÊòØÂè≥ÂÄº
i + j = k; //ÁÆóÊúØË°®ËææÂºèÊòØÂè≥ÂÄº
ci = k; // ciÊòØÂ∏∏Èáè
```

Âè≥ÊâãËæπÁöÑÁ±ªÂûã‰ºöË¢´ËΩ¨ÂåñÊàêÂ∑¶ÊâãËæπÁöÑÁ±ªÂûã„ÄÇ

Âú®Êñ∞Ê†áÂáÜÈáåÔºåÂèØ‰ª•Áî®Ëä±Êã¨Âè∑„ÄÇ

```cpp
k = {3.14}; //error: narrowing conversion
vector<int> vi;
vi = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; //vi now have 10 elements
```

ÊØè‰∏™Êï∞ÊçÆÁ±ªÂûãÂÆö‰πâ‰∫Ü‰∏äÈù¢ÁöÑÊìç‰ΩúÁöÑÂÖ∑‰ΩìÂê´‰πâÔºåÂØπ‰∫évectorÔºåvectorÊ®°ÊùøÂÆö‰πâ‰∫ÜÊìç‰ΩúÁ¨¶„ÄÇ

#### ËµãÂÄºÁ¨¶Âè∑ÊòØright associative

```cpp
int ival, jval;
ival = jval = 0; //ok: each is 0
```

#### ËµãÂÄºÁ¨¶Âè∑ÊúâÁùÄ‰ΩéÁöÑprecedence

‰∏∫‰ªÄ‰πàÂú®Êù°‰ª∂Èáå‰ΩøÁî®ËµãÂÄºÁ¨¶Âè∑ÊòØÊúâÂøÖË¶ÅÁöÑÂë¢Ôºü

```cpp
// a verbose and therefore more error-prone way to write this loop
int i = get_value(); // get remaining values
while (i != 42){
  // do something ...
  i = get_value(); // get remaining values
}
```

ÂàÜÂºÄÂÜô‰∫ÜÔºåÂÆπÊòìÂá∫Èîô

```cpp
int i;
// a better way to write our loop -- what the condition does is now clearer
while ((i = get_value()) != 42){
  // do something ...
}
```

Â¶ÇÊûúÊ≤°ÊúâÊã¨Âè∑Âë¢Ôºå`!=`Â∞Ü‰ºöÊØîËæÉ`get_value`Âíå42„ÄÇiÂ∞Ü‰ºöÂèòÊàêtrueÊàñËÄÖfalseÔºåÊòéÊòæ‰∏çÂØπÂì¶„ÄÇ

#### Â§çÂêàËµãÂÄºÁ¨¶Âè∑

```cpp
+= -= *= /= %= <<= >>= &= ^= |=
```

## 4.5 ÈÄíÂ¢ûÁ¨¶Âè∑ÂíåÈÄíÂáèÁ¨¶Âè∑

‰∏§ÁßçÊñπÂºèÔºå‰∏ÄÁßçÂÜôÂâçÈù¢Ôºå‰∏ÄÁßçÂÜôÂêéÈù¢„ÄÇ

```cpp
int i = 0, j;
j = ++i;  // j = 1; i = 1: prefix yields the incremented value
j = i++;  // j = 1; i = 2: postfix yields the unicremented value
```

#### Âª∫ËÆÆÔºö‰ªÖ‰ªÖÂú®‰∏çÂæó‰∏çÁî®ÁöÑÊó∂ÂÄôÂÜçÁî®ÂêéÁºÄË°®ËææÂºè

Ëøô‰∏™ÂèØËÉΩÂØπcËØ≠Ë®Ä‰ΩøÁî®ËÄÖÂæàÈúáÊÉä„ÄÇÂéüÂõ†ÂæàÁÆÄÂçïÔºö ÈÅøÂÖç‰∫Ü‰∏çÂøÖË¶ÅÁöÑÊìç‰Ωú„ÄÇ‰ΩøÁî®ÂêéÁΩÆËøêÁÆóÁ¨¶È¶ñÂÖàÈúÄË¶Å‰∏Ä‰∏™ÂÆπÂô®Êù•Â≠òÊîæÊú™Â¢ûÂä†ÁöÑÂÄºÔºåÂØπ‰∫éÂ§çÊùÇÁöÑÂÆπÂô®ÔºåÊòØ‰∏ÄÁ¨î‰∏çÂ∞èÁöÑÂºÄÈîÄÔºåÂÖªÊàê‰π†ÊÉØÔºÅ

#### ÁªìÂêàdereferenceÂíåÈÄíÂ¢û

ÂêéÁºÄÈÄíÂ¢ûÁöÑ‰ºòÂÖàÁ∫ßÊòØÈ´ò‰∫éËß£ÂºïÁî®ÁöÑÔºåÊâÄ‰ª•`*pbeg++`ÊòØ‰∏é`*(pbeg++)`Á≠â‰ª∑ÁöÑ„ÄÇÊâÄ‰ª•Ëß£ÂºïÁî®‰ΩúÁî®ÁöÑÊòØÊú™ËøõË°åÈÄíÂ¢ûÊìç‰ΩúÁöÑ„ÄÇËøîÂõûÁöÑÊòØÂéüÂØπË±°ÁöÑ‰∏Ä‰∏™copy„ÄÇ

#### Âª∫ËÆÆÔºöÁÆÄÊ¥ÅÂ∞±ÊòØÁæé

ÂÜôÊàê

 ```cpp
cout << *iter++ << endl;
 ```

ËÄå‰∏çË¶ÅÂÜôÊàê

```cpp
cout << *iter << endl;
++iter;
```

‰∏ãÈù¢ËøôÁßçËôΩÁÑ∂Êõ¥Ê∏ÖÊ•öÔºå‰ΩÜÊòØË¶Å‰π†ÊÉØ‰ΩøÁî®‰∏äÈù¢ÁöÑË°®ËææÂºèÔºå‰∏çÂÆπÊòìÂá∫Èîô„ÄÇ

## 4.6 ÊàêÂëòËé∑ÂèñÊìç‰ΩúÁ¨¶

ÁÇπÂíåÁÆ≠Â§¥„ÄÇÊ≥®ÊÑè.ÁöÑ‰ºòÂÖàÁ∫ßÊØî`*`‰ºòÂÖàÁ∫ßÊõ¥È´ò„ÄÇÊâÄ‰ª•`*p.size()`ÊòØ‰∏çÂêàÊ≥ïÁöÑ„ÄÇ

## 4.7 Êù°‰ª∂Êìç‰ΩúÁ¨¶

ÂèØ‰ª•ÂµåÂ•ó„ÄÇ

```cpp
finalgrade = (grade > 90) ? "high pass"
						  : (grade < 60) ? "fail" : "pass";
```

‰ΩÜÊòØÂæàÈöæÊáÇÔºåÂ∞ΩÈáèÈÅøÂÖçË∂ÖËøá2Â±ÇÁöÑÂµåÂ•ó„ÄÇ

Êù°‰ª∂Êìç‰ΩúÁ¨¶‰ºòÂÖàÁ∫ßÈùûÂ∏∏‰πã‰Ωé„ÄÇÊâÄ‰ª•Â∞ΩÈáèÈÉΩË¶ÅÁî®Êã¨Âè∑„ÄÇ

```cpp
cout << ((grade < 60) ? "fail" : "pass"); //prints pass or fail
cout << (grade < 60) ? "fail" : "pass"; //prints 1 or 0!
cout << grade < 60 ? "fail" : "pass"; //error: compares cout to 60
```

## 4.8 Êåâ‰ΩçÊìç‰ΩúÁ¨¶



### Áßª‰ΩçÊìç‰ΩúÁ¨¶ÁöÑ‰ºòÂÖàÁ∫ßÈóÆÈ¢ò

```cpp
cout << "hi" << "there" << endl;
```

ÂÆûÈôÖ‰∏äÊòØ

```cpp
((cout << "hi") << "there") << endl;
```

Ê≥®ÊÑè‰ºòÂÖàÁ∫ßÊÉÖÂÜµ„ÄÇ

```cpp
cout << 42 + 10; //ok: + has higher precedence, so the sum is printed
cout << (10 < 42); //ok: parentheses force intended grouping; prints 1
cout << 10 < 42; // error: attempt to compare cout to 42
```

## 4.9 sizeof Êìç‰ΩúÁ¨¶

sizeof‰ºöËøîÂõûÂ≠óËäÇÂ§ßÂ∞èÔºåËøîÂõûÂÄºÊòØconst„ÄÇ

ÂèØ‰ª•Êúâ‰∏§ÁßçË°®Á§∫ÊñπÂºèÔºö

```cpp
sizeof(type)
sizeof expr
```



```cpp
Sales_data data, *p;
sizeof(Sales_data); //Sales_dataÁöÑÂ§ßÂ∞è
sizeof data; //dataÁ±ªÂûãÁöÑÂ§ßÂ∞èÔºå‰∏ésizeof(Sales_data)‰∏ÄÊ†∑
sizeof p; //size of a pointer
sizeof *p; //size of the type to which p points.Âíåsizeof(Sales_data)‰∏ÄÊ†∑
sizeof data.revenue; //Sales_dataÁöÑrevenueÁöÑÂ§ßÂ∞è
sizeof Sales_data::revenue; //Âíå‰∏äÈù¢ÁöÑ‰∏ÄÊ†∑
```

sizeof‰ΩøÁî®Ôºö

1. `sizeof char` ÊòØ`char`ÁöÑÂ≠óËäÇÊï∞Â§ßÂ∞è
2. `sizeof` ‰∏Ä‰∏™ÂºïÁî®ËøîÂõûÁöÑÊòØÂºïÁî®Á±ªÂûãÁöÑÂ§ßÂ∞è„ÄÇ
3. `sizeof`ÊåáÈíàËøîÂõûÁöÑÊòØË¶ÅÂ≠ò‰∏Ä‰∏™ÊåáÈíàÊâÄÈúÄË¶ÅÁöÑÂ§ßÂ∞è
4. `sizeof`‰∏Ä‰∏™Ëß£ÂºïÁî®ÁöÑÊåáÈíàËøîÂõûÁöÑÊòØËøô‰∏™‰∏úË•øÁöÑÁ±ªÂûã„ÄÇ
5. `sizeof`‰∏Ä‰∏™Êï∞ÁªÑÊòØÂÖ®Êï∞ÁªÑÁöÑÂ§ßÂ∞èÔºåÊ≥®ÊÑèsizeof‰∏ç‰ºöÊääÊï∞ÁªÑËΩ¨ÂåñÊàê‰∏Ä‰∏™ÊåáÈíà„ÄÇ
6. `sizeof`‰∏Ä‰∏™stringÊàñËÄÖvectorËøîÂõûÁöÑÊòØfixed partÁöÑÂ§ßÂ∞èÔºåÂπ∂‰∏çÊòØ‰ΩøÁî®ÁöÑÂ§ßÂ∞è„ÄÇ

## 4.10 ÈÄóÂè∑Êìç‰ΩúÁ¨¶

 ‰ªéÂ∑¶Âà∞Âè≥ÊâßË°åÁöÑ„ÄÇÂ∑¶ËæπÁöÑÊâßË°å‰∫Ü‰ΩÜÊòØÁªìÊûúË¢´ÂøΩÁï•Êéâ„ÄÇÂè≥ËæπÊâßË°åÁªìÊûúÊòØËøîÂõûÂÄº„ÄÇÂΩìÂ§ÑÂú®forÂæ™ÁéØÁöÑÊó∂ÂÄôÔºö

```cpp
vector<int>::size_type cnt = ivec.size();
// assign values from size... 1 to the elements in ivec
for (vector<int>::size_type ix = 0; ix != ivec.size(); ++ix, --cnt)
	ivec[ix] = cnt;
```

## 4.11 Á±ªÂûãËΩ¨Êç¢

‰∏æ‰æãÔºö

```cpp
int ival = 3.541 + 3; // the compiler might warn about loss of precision
```

ÈªòËÆ§ÊÉÖÂÜµ‰∏ãÔºå3.541ÊòØdoubleÔºå3ÊòØint„ÄÇ

#### ‰ªÄ‰πàÊó∂ÂÄô‰ºöÂèëÁîüimplicit conversionsÔºü

* Âú®Â§ßÂ§öÊï∞Ë°®ËææÂºè‰∏≠ÔºåÊØîintËøòÂ∞èÁöÑÊï¥ÂûãÁ±ªÂûãÈ¶ñÂÖà‰ºöËΩ¨Êàê‰∏Ä‰∏™ÊØîÊï¥ÂûãÂ§ß‰∏ÄÁÇπÁöÑÊï¥Âûã„ÄÇ
* Âú®Êù°‰ª∂Ë°®ËææÂºè‰∏≠ÔºåÈùûÂ∏ÉÂ∞îÁöÑË°®ËææÂºèÂ∞Ü‰ºöËΩ¨ÂåñÊàêbool„ÄÇ
* Âú®ÂàùÂßãÂåñËøáÁ®ã‰∏≠Ôºåinitializer‰ºöÊääÁ±ªÂûãËΩ¨ÂåñÊàêÂèòÈáèÁöÑÁ±ªÂûãÔºõÂú®ËµãÂÄºÊó∂ÔºåÂè≥ÊâãËæπÁöÑË°®ËææÂºèÁ±ªÂûã‰ºöËΩ¨ÊàêÂ∑¶ÊâãËæπÁöÑÁ±ªÂûã„ÄÇ
* Âú®ÁÆóÊúØË°®ËææÂºèÊàñÂÖ≥Á≥ªË°®ËææÂºèÁ≠â‰ΩøÁî®Â§öÁßçÁ±ªÂûãÁöÑË°®ËææÂºèÊó∂ÔºåÁ±ªÂûãË¢´ËΩ¨Âåñ‰∏∫‰∏Ä‰∏™Â∏∏Áî®Á±ªÂûã„ÄÇ
* Á¨¨ÂÖ≠Á´†ÈáåËøò‰ºöÊúâËØ¶Ëß£ÔºåÂèëÁîüÂú®Ë∞ÉÁî®ÂáΩÊï∞Êó∂„ÄÇ

### 4.11.1 ÁÆóÊúØËΩ¨Âåñ

ÁÆóÊúØËΩ¨ÂåñÁöÑ‰ª£Ë°®ÁùÄ‰∏Ä‰∏™ÂàÜÁ∫ßÁöÑËΩ¨ÂåñËøáÁ®ãÔºåÂÖ∂‰ΩôÁöÑÂΩ¢ÂºèÈÉΩËΩ¨ÂåñÊàêwidestÁöÑÁ±ªÂûã„ÄÇ

#### Êï¥ÂûãÊèêÂçá(Integral Promotions)

Êää‰∏Ä‰∏™Â∞èÊï¥ÂûãËΩ¨ÂåñÊàê‰∏Ä‰∏™Â§ßÊï¥Âûã„ÄÇ‰æãÂ¶ÇÔºåÂú®ÂΩìÊâÄÊúâÁöÑÂÄºÈÉΩÊª°Ë∂≥`int`Êó∂ÔºåÊää`bool, char, signed char, unsigned char, short, unsigned short`Á≠âÈÉΩÊèêÂçáÊàêint„ÄÇÂ¶ÇÊûú‰∏çÁ¨¶ÂêàÁöÑËØùÔºåÊèêÂçá‰∏∫`unsigned int`„ÄÇÂ∞±ÊØîÂ¶ÇÔºåboolÁöÑfalseÊòØ0ÔºåtrueÊòØ1„ÄÇ

Â§ßÁöÑcharÔºàwchar_t, char16_t, char32_tÔºâ‰ºöË¢´ËΩ¨Êàêint, unsigned int, long, unsigned long, long long, ÊàñËÄÖunsigned long longÁ≠â‰∏Ä‰∏™ËÉΩÁõõ‰∏ãËØ•ÂèòÈáèÁöÑÂÄº„ÄÇ

#### Êó†Á¨¶Âè∑Á±ªÂûãÊìç‰ΩúÁöÑÊìç‰ΩúÂØπË±°

Â¶ÇÊûú‰∏Ä‰∏™Êìç‰ΩúÁ¨¶ÁöÑÊìç‰ΩúÂØπË±°ÊúâÁùÄ‰∏çÂêåÁöÑÁ±ªÂûãÔºåËøô‰∫õÊìç‰ΩúÂØπË±°‰ºöËΩ¨ÂåñÊàêÁªü‰∏ÄÁöÑÁ±ªÂûã„ÄÇÂ¶ÇÊûúÊúâÊìç‰ΩúÂØπË±°ÊòØunsignedÁ±ªÂûãÁöÑËØùÔºåÊìç‰ΩúÂØπË±°ËΩ¨Êàê‰ªÄ‰πàÂ∞±ÂèñÂÜ≥‰∫éÊï¥ÂûãÂØπË±°Âú®Êú∫Âô®‰∏≠ÁöÑÁõ∏ÂØπÂ§ßÂ∞è„ÄÇ

Â∞±‰∏ÄËà¨ËÄåË®ÄÔºåÈ¶ñÂÖà‰ºöÂèëÁîüÊï¥ÂûãÊèêÂçá„ÄÇÂ¶ÇÊûúÁªìÊûúÁ±ªÂûãÁ¨¶ÂêàÊ†áÂáÜÔºåÂ∞±‰∏çËøõË°åÈ¢ùÂ§ñÁöÑËΩ¨Êç¢‰∫Ü„ÄÇÂ¶ÇÊûúÂêåÂè∑Â∞±Â∞èÁöÑËΩ¨ÊàêÂ§ßÁöÑ„ÄÇ

unsignedÁ¨¶Âè∑Ë¶ÅÊØîsignedÂ§ß„ÄÇ

```cpp
bool flag; 
short sval; 
int ival; 
long lval; 
float fval;
char cval; 
unsigned short usval; 
unsigned int uival; 
unsigned long ulval; 
double dval;

3.14159L + 'a'; //'a' promoted to int, then that int converted to long double
dval + ival; // ival converted to double
dval + fval; // fval converted to double
ival = dval; // dval converted (by truncation) to int
flag = dval; // if dval is 0, then flag is false, otherwise true
cval + fval; // cval promoted to int, then that int converted to float
sval + cval; // sval and cval promoted to int
cval + lval; // cval converted to long
ival + ulval; // ival converted to unsigned long
usval + ival; // promotion depends on the size of unsigned short and int
uival + lval; // conversion depends on the size of unsigned int and long

```

### 4.11.2 ÂÖ∂‰ªñÁßçÁ±ªÁöÑimplicit ËΩ¨Êç¢

Array to pointerËΩ¨Êç¢Ôºö

```cpp
int ia[10]; //array of ten ints
int* ip = ia; //convert ia to a pointer to the first element
```

pointer ËΩ¨Êç¢Ôºö

Êï¥Êï∞Êï∞ÂÄºÂ∏∏Êï∞0ÊàñËÄÖnullptrÂèØ‰ª•ËΩ¨ÂåñÊàê‰ªª‰ΩïÊåáÈíàÁ±ªÂûã„ÄÇÈùûÂ∏∏Êï∞Á±ªÂûãÁöÑÊåáÈíàÂèØ‰ª•ËΩ¨ÂåñÊàê`void *`„ÄÇ‰ªª‰ΩïÁ±ªÂûãÁöÑÊåáÈíàÈÉΩÂèØ‰ª•ËΩ¨‰∏∫`const void *`„ÄÇ

boolËΩ¨Êç¢Ôºö

Â¶ÇÊûú‰∏Ä‰∏™ÊåáÈíàÊàñËÄÖarithmeticÂÄºÊòØ0ÔºåÂàôËΩ¨ÊàêfalseÔºåÂê¶ÂàôÂ∞±ÊòØtrue„ÄÇ

constËΩ¨Êç¢Ôºö

ÈùûÂ∏∏ÊåáÈíàÂèØ‰ª•ËΩ¨Âåñ‰∏∫Â∏∏ÊåáÈíàÔºåÂºïÁî®‰πüÊòØ„ÄÇ

```cpp
int i;
const int &j = i; //convert a nonconst to a reference to const int
const int *p = &i; //convert address of a nonconst to the address of a const
int &r = j, *q = p; //error: conversion from const to nonconst not allowed
```

ÂèçËøáÊù•ÊòØ‰∏çË°åÁöÑ„ÄÇ

### 4.11.3 ÊòæÂºèËΩ¨Êç¢

#### Warning

castsÊòØÂç±Èô©ÁöÑÊìç‰ΩúÔºåËôΩÁÑ∂ÊúâÊó∂ÂÄôÂøÖÈ°ªË¶ÅÊúâ„ÄÇ

```cpp
cast-name<type>(expressions);
```

ÂÖ∂‰∏≠ÔºåtypeÊòØËΩ¨Êç¢ÁöÑÁõÆÊ†áÁ±ªÂûã„ÄÇexpressionsÊòØËΩ¨Êç¢ÂéüÂßãÂÄº„ÄÇ

cast-nameÂåÖÊã¨Ôºö

```c
static_cast
dynamic_cast
const_cast
reinterpret_cast
```

static_castÁî®‰∫éÊää‰∏Ä‰∏™Â§ßÁ±ªÂûãËΩ¨Âåñ‰∏∫Â∞èÁöÑÁ±ªÂûã„ÄÇÈò≤Ê≠¢ÁºñËØëÂô®Êä•Ë≠¶„ÄÇ

#### const_cast

const_castÂèØ‰ª•ËΩ¨Êç¢‰∏Ä‰∏™‰ΩéÁ∫ßÂà´ÁöÑÊìç‰ΩúÂØπË±°„ÄÇ

```cpp
const char *pc;
char *p = const_cast<char*>(pc); // ok: but writing through p is undefined
```

‰ΩøÁî®Ëøô‰∏™Â∞ÜÈùûconstÁöÑËΩ¨ÊàêconstÁöÑÊòØÊúâÊïàÁöÑ„ÄÇÁÑ∂ËÄåÔºå‰ΩøÁî®`const_cast`Êù•‰ΩøconstÂèØÂÜôÊòØÊ≤°ÊúâÂÆö‰πâÁöÑ„ÄÇ

```cpp
const char *cp;
char *q = static_cast<char*>(cp); // error: static_cast can't cast away const
static_cast<string>(cp); //ok: converts string literal to string
const_cast<string>(cp); //error: const_cast only changes constness
```

const_castÂ∏∏Â∏∏Áî®‰∫éÈáçËΩΩ„ÄÇ

#### reinterpret_cast

Ëøô‰∏™ÊòØÂæàÂç±Èô©ÁöÑ„ÄÇ

```cpp
int *ip;
char* pc = reinterpret_cast<char*>(ip);
```

Ëøô‰∏™‰ªÄ‰πàÈîôÈÉΩ‰∏ç‰ºöÊä•„ÄÇ‰ΩÜÊòØÂΩìËøêË°åÔºö

``` cpp
string str(pc);
```

Êó∂ÂÄôÔºåÂ∞±‰ºöÊä•run-time behaviorÈîô„ÄÇ

#### warning

Ëøô‰∏™reinterpret_castÊú¨Ë¥®‰∏ä‰æùËµñ‰∫éÊú∫Âô®„ÄÇÂøÖÈ°ªÂØπÁºñËØëÂÆûÁé∞ÈùûÂ∏∏‰∫ÜËß£ÊâçËÉΩÁü•ÈÅìÊÄé‰πà‰∏çÁî®Èîô„ÄÇ

 



