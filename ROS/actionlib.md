# actionlib

## overview

* want the ability to cancel the request during execution
* get periodic feedback about how the request is progressing.

actionlib provides:

* tools to create servers that execute long-running goals that can be preempted.
* provides a client interface in order to send requests to the server.

## action specification: goal, feedback, result

### goal

To accomplish tasks using actions, we introduce the notion of a goal that can be sent to an ActionServer by an ActionClient.

### feedback

Feedback provides server implementers a way to tell an ActionClient about the incremental progress of a goal.

### Result

A result is sent from the ActionServer to the ActionClient upon completion of the goal

## .action File

The action specification is defined using a .action file. The .action file has the goal definition, followed by the result definition, followed by the feedback definition, with each section separated by 3 hyphens(---)

./action/DoDishes.action

    # Define the goal
    uint32 dishwasher_id  # Specify which dishwasher we want to use
    ---
    # Define the result
    uint32 total_dishes_cleaned
    ---
    # Define a feedback message
    float32 percent_complete

## Catkin

Add the following to your CMakeLists.txt file before catkin_package().

    find_package(catkin REQUIRED genmsg actionlib_msgs actionlib)
    add_action_files(DIRECTORY action FILES DoDishes.action)
    generate_messages(DEPENDENCIES actionlib_msgs)

Additionally, the package's package.xml must include the following dependencies:

    <build_depend>actionlib</build_depend>
    <build_depend>actionlib_msgs</build_depend>
    <run_depend>actionlib</run_depend>
    <run_depend>actionlib_msgs</run_depend>

## Results

For the DoDishes.action, the following messages are generated by genaction.py

    DoDishesAction.msg
    DoDishesActionGoal.msg
    DoDishesActionResult.msg
    DoDishesActionFeedback.msg
    DoDishesGoal.msg
    DoDishesResult.msg
    DoDishesFeedback.msg

# workspace setup

    $ cd %YOUR_CATKIN_WORKSPACE%/src
    $ catkin_create_pkg actionlib_tutorials actionlib message_generation roscpp rospy std_msgs actionlib_msgs

# Writing a simple action server using the execute callback

## creating the action messages

Fibonacci.action

    #goal definition
    int32 order
    ---
    #result definition
    int32[] sequence
    ---
    #feedback
    int32[] sequence

</br>

To automatically generate the message files during the make process, a few things need to be added to CMakeLists.txt

* add the actionlib_msgs package to the find_package macro's argument like this (if you used catkin_create_package to generate CMakeLists.txt, this may already have been added):

      find_package(catkin REQUIRED COMPONENTS actionlib_msgs)
* use the add_action_files macro to declare the actions you want to be generated:

      add_action_files(
      DIRECTORY action
      FILES Fibonacci.action
      )
* call the generate_messages macro, not forgetting the dependencies on actionlib_msgs and other message packages like std_msgs:

      generate_messages(
        DEPENDENCIES actionlib_msgs std_msgs  # Or other packages containing msgs
      )
* add actionlib_msgs to catkin_package macro like this:

      catkin_package(
        CATKIN_DEPENDS actionlib_msgs
      )

* catkin_make


## Writing a Simple Server

### The Code

    #include <ros/ros.h>
    #include <actionlib/server/simple_action_server.h>
    #include <actionlib_tutorials/FibonacciAction.h>

    class FibonacciAction
    {
    protected:

      ros::NodeHandle nh_;
      actionlib::SimpleActionServer<actionlib_tutorials::FibonacciAction> as_; // NodeHandle instance must be created before this line. Otherwise strange error occurs.
      std::string action_name_;
      // create messages that are used to published feedback/result
      actionlib_tutorials::FibonacciFeedback feedback_;
      actionlib_tutorials::FibonacciResult result_;

    public:

      FibonacciAction(std::string name) :
        as_(nh_, name, boost::bind(&FibonacciAction::executeCB, this, _1), false),
        action_name_(name)
      {
        as_.start();
      }

      ~FibonacciAction(void)
      {
      }

      void executeCB(const actionlib_tutorials::FibonacciGoalConstPtr &goal)
      {
        // helper variables
        ros::Rate r(1);
        bool success = true;

        // push_back the seeds for the fibonacci sequence
        feedback_.sequence.clear();
        feedback_.sequence.push_back(0);
        feedback_.sequence.push_back(1);

        // publish info to the console for the user
        ROS_INFO("%s: Executing, creating fibonacci sequence of order %i with seeds %i, %i", action_name_.c_str(), goal->order, feedback_.sequence[0], feedback_.sequence[1]);

        // start executing the action
        for(int i=1; i<=goal->order; i++)
        {
          // check that preempt has not been requested by the client
          if (as_.isPreemptRequested() || !ros::ok())
          {
            ROS_INFO("%s: Preempted", action_name_.c_str());
            // set the action state to preempted
            as_.setPreempted();
            success = false;
            break;
          }
          feedback_.sequence.push_back(feedback_.sequence[i] + feedback_.sequence[i-1]);
          // publish the feedback
          as_.publishFeedback(feedback_);
          // this sleep is not necessary, the sequence is computed at 1 Hz for demonstration purposes
          r.sleep();
        }

        if(success)
        {
          result_.sequence = feedback_.sequence;
          ROS_INFO("%s: Succeeded", action_name_.c_str());
          // set the action state to succeeded
          as_.setSucceeded(result_);
        }
      }


    };


    int main(int argc, char** argv)
    {
      ros::init(argc, argv, "fibonacci");

      FibonacciAction fibonacci("fibonacci");
      ros::spin();

      return 0;
    }

## Compiling

Add the following lines to CmakeLists.txt file:

    add_executable(fibonacci_server src/fibonacci_server.cpp)

    target_link_libraries(
      fibonacci_server
      ${catkin_LIBRARIES}
    )

    add_dependencies(
      fibonacci_server
      ${actionlib_tutorials_EXPORTED_TARGETS}
    )

# Writing a Simple Action client

## The Code

    #include <ros/ros.h>
    #include <actionlib/client/simple_action_client.h>
    #include <actionlib/client/terminal_state.h>
    #include <actionlib_tutorials/FibonacciAction.h>

    int main (int argc, char **argv)
    {
      ros::init(argc, argv, "test_fibonacci");

      // create the action client
      // true causes the client to spin its own thread
      actionlib::SimpleActionClient<actionlib_tutorials::FibonacciAction> ac("fibonacci", true);

      ROS_INFO("Waiting for action server to start.");
      // wait for the action server to start
      ac.waitForServer(); //will wait for infinite time

      ROS_INFO("Action server started, sending goal.");
      // send a goal to the action
      actionlib_tutorials::FibonacciGoal goal;
      goal.order = 20;
      ac.sendGoal(goal);

      //wait for the action to return
      bool finished_before_timeout = ac.waitForResult(ros::Duration(30.0));

      if (finished_before_timeout)
      {
        actionlib::SimpleClientGoalState state = ac.getState();
        ROS_INFO("Action finished: %s",state.toString().c_str());
      }
      else
        ROS_INFO("Action did not finish before the time out.");

      //exit
      return 0;
    }

## Compiling

    add_executable(fibonacci_client src/fibonacci_client.cpp)

    target_link_libraries(
      fibonacci_client
      ${catkin_LIBRARIES}
    )

    add_dependencies(
      fibonacci_client
      ${actionlib_tutorials_EXPORTED_TARGETS}
    )
